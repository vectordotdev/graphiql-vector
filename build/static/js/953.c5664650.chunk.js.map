{"version":3,"file":"static/js/953.c5664650.chunk.js","mappings":"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","sources":["../node_modules/@graphiql/react/dist/Range.es.js","../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../node_modules/graphql/language/predicates.mjs","../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../node_modules/graphql/jsutils/groupBy.mjs","../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../node_modules/graphql/utilities/sortValueNode.mjs","../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../node_modules/graphql/execution/values.mjs","../node_modules/graphql/execution/collectFields.mjs","../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../node_modules/graphql/validation/specifiedRules.mjs","../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs","../node_modules/graphql/validation/ValidationContext.mjs","../node_modules/graphql/validation/validate.mjs","../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../node_modules/@graphiql/react/dist/lint.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n","/**\n * Groups array items into a Map, given a function to produce grouping key.\n */\nexport function groupBy(list, keyFn) {\n  const result = new Map();\n\n  for (const item of list) {\n    const key = keyFn(item);\n    const group = result.get(key);\n\n    if (group === undefined) {\n      result.set(key, [item]);\n    } else {\n      group.push(item);\n    }\n  }\n\n  return result;\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n","import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n","import { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Sort ValueNode.\n *\n * This function returns a sorted copy of the given ValueNode.\n *\n * @internal\n */\n\nexport function sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return { ...valueNode, fields: sortFields(valueNode.fields) };\n\n    case Kind.LIST:\n      return { ...valueNode, values: valueNode.values.map(sortValueNode) };\n\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\n\nfunction sortFields(fields) {\n  return fields\n    .map((fieldNode) => ({\n      ...fieldNode,\n      value: sortValueNode(fieldNode.value),\n    }))\n    .sort((fieldA, fieldB) =>\n      naturalCompare(fieldA.name.value, fieldB.name.value),\n    );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  const args =\n    /* c8 ignore next */\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\n    _fieldNode$arguments !== void 0\n      ? _fieldNode$arguments\n      : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value,\n    })),\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isInputType, isNonNullType } from '../type/definition.mjs';\nimport { coerceInputValue } from '../utilities/coerceInputValue.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { valueFromAST } from '../utilities/valueFromAST.mjs';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = print(varDefNode.type);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error.originalError,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isNonNullType } from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport { specifiedRules, NoUnusedFragmentsRule, ExecutableDefinitionsRule, KnownFragmentNamesRule, validate, Kind, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, print, parse, GraphQLError, NoDeprecatedCustomRule } from \"graphql\";\nimport { o as onlineParser } from \"./types.es.js\";\nimport { C as CharacterStream, R as Range, P as Position } from \"./Range.es.js\";\nimport \"./index.es.js\";\nimport \"react\";\nimport \"react-dom\";\nconst specifiedSDLRules = [\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule\n];\nfunction validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n  const rules = specifiedRules.filter((rule) => {\n    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n      return false;\n    }\n    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n      return false;\n    }\n    return true;\n  });\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n  if (isSchemaDocument) {\n    Array.prototype.push.apply(rules, specifiedSDLRules);\n  }\n  const errors = validate(schema, ast, rules);\n  return errors.filter((error) => {\n    if (error.message.indexOf(\"Unknown directive\") !== -1 && error.nodes) {\n      const node = error.nodes[0];\n      if (node && node.kind === Kind.DIRECTIVE) {\n        const name = node.name.value;\n        if (name === \"arguments\" || name === \"argumentDefinitions\") {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n}\n__name(validateWithCustomRules, \"validateWithCustomRules\");\nconst SEVERITY$1 = {\n  Error: \"Error\",\n  Warning: \"Warning\",\n  Information: \"Information\",\n  Hint: \"Hint\"\n};\nconst DIAGNOSTIC_SEVERITY = {\n  [SEVERITY$1.Error]: 1,\n  [SEVERITY$1.Warning]: 2,\n  [SEVERITY$1.Information]: 3,\n  [SEVERITY$1.Hint]: 4\n};\nconst invariant = /* @__PURE__ */ __name((condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n}, \"invariant\");\nfunction getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  var _a, _b;\n  let ast = null;\n  if (externalFragments) {\n    if (typeof externalFragments === \"string\") {\n      query += \"\\n\\n\" + externalFragments;\n    } else {\n      query += \"\\n\\n\" + externalFragments.reduce((agg, node) => {\n        agg += print(node) + \"\\n\\n\";\n        return agg;\n      }, \"\");\n    }\n  }\n  try {\n    ast = parse(query);\n  } catch (error) {\n    if (error instanceof GraphQLError) {\n      const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, query);\n      return [\n        {\n          severity: DIAGNOSTIC_SEVERITY.Error,\n          message: error.message,\n          source: \"GraphQL: Syntax\",\n          range\n        }\n      ];\n    }\n    throw error;\n  }\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\n__name(getDiagnostics, \"getDiagnostics\");\nfunction validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Error, \"Validation\"));\n  const deprecationWarningAnnotations = mapCat(validate(schema, ast, [NoDeprecatedCustomRule]), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Warning, \"Deprecation\"));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\n__name(validateQuery, \"validateQuery\");\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n__name(mapCat, \"mapCat\");\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n  const highlightedNodes = [];\n  error.nodes.forEach((node) => {\n    const highlightNode = node.kind !== \"Variable\" && \"name\" in node && node.name !== void 0 ? node.name : \"variable\" in node && node.variable !== void 0 ? node.variable : node;\n    if (highlightNode) {\n      invariant(error.locations, \"GraphQL validation error requires locations.\");\n      const loc = error.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type}`,\n        message: error.message,\n        severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\n__name(annotations, \"annotations\");\nfunction getRange(location, queryText) {\n  const parser = onlineParser();\n  const state = parser.startState();\n  const lines = queryText.split(\"\\n\");\n  invariant(lines.length >= location.line, \"Query text must have more lines than where the error happened\");\n  let stream = null;\n  for (let i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n      if (style === \"invalidchar\") {\n        break;\n      }\n    }\n  }\n  invariant(stream, \"Expected Parser stream to be available.\");\n  const line = location.line - 1;\n  const start = stream.getStartOfToken();\n  const end = stream.getCurrentPosition();\n  return new Range(new Position(line, start), new Position(line, end));\n}\n__name(getRange, \"getRange\");\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant(location, \"Expected ASTNode to have a location.\");\n  return location;\n}\n__name(getLocation, \"getLocation\");\nconst SEVERITY = [\"error\", \"warning\", \"information\", \"hint\"];\nconst TYPE = {\n  \"GraphQL: Validation\": \"validation\",\n  \"GraphQL: Deprecation\": \"deprecation\",\n  \"GraphQL: Syntax\": \"syntax\"\n};\nCodeMirror.registerHelper(\"lint\", \"graphql\", (text, options) => {\n  const schema = options.schema;\n  const rawResults = getDiagnostics(text, schema, options.validationRules, void 0, options.externalFragments);\n  const results = rawResults.map((error) => ({\n    message: error.message,\n    severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n    type: error.source ? TYPE[error.source] : void 0,\n    from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n    to: CodeMirror.Pos(error.range.end.line, error.range.end.character)\n  }));\n  return results;\n});\n"],"names":["__defProp","Object","defineProperty","__name","target","value","configurable","CharacterStream","sourceText","this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","caseFold","token","regex","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whitespaces","pos","charCodeAt","current","character","Range","start","end","containsPosition","line","Position","lessThanOrEqualTo","LoneSchemaDefinitionRule","context","_ref","_ref2","_oldSchema$astNode","oldSchema","getSchema","alreadyDefined","astNode","getQueryType","getMutationType","getSubscriptionType","schemaDefinitionsCount","SchemaDefinition","node","reportError","GraphQLError","nodes","UniqueOperationTypesRule","schema","definedOperationTypes","create","existingOperationTypes","query","mutation","subscription","checkOperationTypes","SchemaExtension","_node$operationTypes","operationTypesNodes","operationTypes","operationType","operation","alreadyDefinedOperationType","UniqueTypeNamesRule","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","typeName","name","getType","UniqueEnumValueNamesRule","existingTypeMap","getTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","UniqueFieldDefinitionNamesRule","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","type","isObjectType","isInterfaceType","isInputObjectType","getFields","UniqueDirectiveNamesRule","knownDirectiveNames","DirectiveDefinition","directiveName","getDirective","isExecutableDefinitionNode","kind","Kind","isTypeSystemDefinitionNode","isTypeDefinitionNode","isTypeSystemExtensionNode","isTypeExtensionNode","KnownTypeNamesRule","existingTypesMap","definedTypes","getDocument","definitions","def","typeNames","keys","NamedType","_1","parent","_2","ancestors","_ancestors$","definitionNode","isSDL","standardTypeNames","includes","suggestedTypes","suggestionList","concat","didYouMean","specifiedScalarTypes","introspectionTypes","map","KnownDirectivesRule","locationsMap","definedDirectives","getDirectives","specifiedDirectives","directive","locations","astDefinitions","Directive","_key","_parent","_path","candidateLocation","appliedTo","invariant","OperationTypeNode","DirectiveLocation","getDirectiveLocationForOperation","parentNode","inspect","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","directives","seenDirectives","undefined","PossibleTypeExtensionsRule","ScalarTypeExtension","checkExtension","UnionTypeExtension","expectedKind","defNode","defKindToExtKind","isScalarType","isUnionType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","groupBy","list","keyFn","result","Map","item","key","group","get","set","push","UniqueArgumentNamesRule","Field","checkArgUniqueness","_parentNode$arguments","seenArgs","arguments","arg","argName","argNodes","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","leave","prevKnownNames","pop","ObjectField","ExecutableDefinitionsRule","Document","definition","defName","KnownArgumentNamesOnDirectivesRule","directiveArgs","args","_def$arguments","argsNodes","directiveNode","knownArgs","argNode","suggestions","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","fragmentNameUsed","getRecursivelyReferencedFragments","fragmentDef","fragName","sortValueNode","valueNode","fieldNode","sort","fieldA","fieldB","naturalCompare","reasonMessage","reason","isArray","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","getReferencedFieldsAndFragmentNames","fieldMap2","referencedFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","parentFieldsAreMutuallyExclusive","entries","fields1","fields2","field1","conflict","findConflict","field2","parentType1","node1","def1","parentType2","node2","def2","name1","name2","stringifyArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","getFieldsAndFragmentNames","fragmentNames1","fragmentNames2","findConflictsBetweenSubSelectionSets","getNamedType","flat","subfieldConflicts","_fieldNode$arguments","inputObjectWithArgs","print","isListType","ofType","isNonNullType","isLeafType","parentType","cached","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","fragmentType","typeFromAST","typeCondition","selections","selection","alias","inlineFragmentType","PairSet","_data","a","b","_this$_data$get","key1","key2","ProvidedRequiredArgumentsOnDirectivesRule","_schema$getDirectives","requiredArgsMap","keyMap","filter","isRequiredArgument","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","argNodeMap","Set","argDef","argType","isType","defaultValue","getDirectiveValues","directiveDef","variableValues","_node$directives","find","_node$arguments","coercedValues","argumentNodes","argumentNode","isNull","variableName","hasOwnProperty","coercedValue","valueFromAST","getArgumentValues","obj","prop","prototype","call","collectFieldsImpl","fragments","runtimeType","visitedFragmentNames","shouldIncludeNode","fieldList","doesFragmentConditionMatch","skip","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","isAbstractType","isSubType","isValidValueNode","locationType","getInputType","parseLiteral","typeStr","error","message","originalError","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","nullableLocationType","isTypeSubTypeOf","specifiedRules","freeze","knownOperationNames","operationName","operationCount","subscriptionType","document","collectFields","size","extraFieldSelections","InlineFragment","isCompositeType","VariableDefinition","isInputType","variable","getParentType","getFieldDef","suggestion","usageCount","getPossibleTypes","possibleType","getInterfaces","_usageCount$possibleI","possibleInterface","typeA","typeB","usageCountDiff","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","doTypesOverlap","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","s","operationNode","_operationNode$variab","seenVariableDefinitions","variableDefinitions","variableNodes","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","variableDef","Argument","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","field","isRequiredInputField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","providedArgs","argTypeStr","varDefMap","varDef","varTypeStr","SelectionSet","i","j","collectConflictsWithin","findConflictsWithinSelectionSet","reasonMsg","checkArgUniquenessPerField","typeNode","_typeNode$fields","_fieldDef$arguments","parentName","ASTValidationContext","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","spreads","setsToVisit","collectedNames","nodesToVisit","Symbol","toStringTag","ValidationContext","typeInfo","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","newUsages","TypeInfo","visit","visitWithTypeInfo","Variable","getDefaultValue","getVariableUsages","getEnumValue","validate","documentAST","_options$maxErrors","rules","options","maxErrors","devAssert","assertValidSchema","abortObj","errors","visitor","visitInParallel","rule","e","NoDeprecatedCustomRule","deprecationReason","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","specifiedSDLRules","validateWithCustomRules","customRules","isRelayCompatMode","isSchemaDocument","apply","indexOf","SEVERITY$1","DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","_a","_b","externalFragments","reduce","agg","parse","range","getRange","severity","source","validateQuery","validationErrorAnnotations","mapCat","annotations","deprecationWarningAnnotations","Warning","array","mapper","highlightedNodes","forEach","highlightNode","loc","highlightLoc","getLocation","location","queryText","parser","onlineParser","state","startState","lines","split","stream","SEVERITY","TYPE","CodeMirror","text","validationRules","from","to"],"sourceRoot":""}